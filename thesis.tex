
%Remove these comments at end if they are fulfilled

% Before you begin, make sure that:
% - research question is clear
% - main points(contribution)+goal are clear (to be repeated throughout+title)
% - clear validation, evaluation, method of exactly the research question with main points as outcome!!!
% - Brainstorming was done
% - Roter Faden was done (Strukturierung und Elimination of Abzweigung)



\iffalse
NOTES:
- Why TOML?
	* Used by many projects
		-> eg cargo, pip -> where exactly
		-> possiblities for usage of elektra
	* No TOML plugin existing (only via augeas plugin)
- What was done?
	* TOML storage plugin for elektra
	* For now limited to reading toml files
	* uses c, flex, bison
- Case Study
	* lcdproc

	
\fi

\documentclass[12pt]{report}
\usepackage[utf8]{inpute nc}
\usepackage[acronym,nomain]{glossaries}
\usepackage{cite}
\usepackage{hyperref}

\title{Viability of TOML parsing for configuration}
\author{Jakob Fischer}


\bibliographystyle{unsrt}
\makeglossaries

\newacronym{LL}{LL}{Left-to-Right, Leftmost derivation}
\newacronym{LR}{LR}{Left-to-Right, Rightmost derivation}
\newacronym{TOML}{TOML}{Tom's Obvious, Minimal Language}
\newacronym{FLEX}{FLEX}{Fast Lexical Analyzer}

\newcommand{\onlinesrc}[1]{Accessed #1}
\newcommand{\gitsrc}[1]{Commit \##1}

\begin{document}

\maketitle

\begin{abstract}
TODO: Abstract
\end{abstract}

\chapter{Introduction}


\section{\acrshort{TOML} (\acrlong{TOML})}
\acrshort{TOML} is a configuration file format developed since February, 2013 \cite{tomlcontrib}.
It claims to be a format, that is easily to read and parse \cite{tomlreadme} and finds use in many different projects \cite{tomlwiki}.
For instance, it is used with Rusts project manager \textbf{cargo} \cite{cargogit}, as well as Pythons package installer \textbf{pip} \cite{piprefguide}.

\section{Elektra}
Elektra is a configuration framework for accessing configuration settings in a global key database \cite{elektramain}.
An application using Elektra can read and write key/value pairs via calls to the Elektra library, making the implementation of an own configuration system obsolete.
Furthermore, elektrified applications can access configuration settings of other elektrified applications, to provide better application interoperability.

Although Elektra is mainly written in C, there are bindings for other languages like java, python or ruby \cite{elektrabindings}.

Elektra can also read from and write to different configuration file formats, like JSON, XML or ini \cite{elektrastorage}.
If the need arises, applications can easily switch to a different file format, because configuration access is done with the Elektra API.
Developers or Administrators no longer need to commit to one file format for configuration.

Support for different languages and file formats is implemented by the use of plugins, which can be enabled if needed.
With this modularity, Elektra can provide a wide range of functionality, while simultaneously avoiding being a bloated library.
Developers can compile Elektra with the exact set of needed functionality. If they don't need bindings for java, they can just disable this feature.

\section{lcdproc}
LCDproc is an open source project for displaying stats like CPU/RAM usage of a system on different kinds of LCD devices \cite{lcdprocmain}\cite{lcdprocgit}.
It has a client/server architecture, where the server provides it's system stats to multiple clients, which then display it on a LCD device.

\section{Research Question}
We will test the newly written toml plugin on lcdproc, which currently stores it's configuration in an ini like format \cite{lcdprocconf}.
It uses a custom parser to read the configuration \cite{lcdprocconfigreader}.

There are two important questions we want to answer for the toml plugin:
\begin{itemize}
	\item[RQ1] Does the plugin correctly load all needed lcdproc configuration settings?
	\item[RQ2] Does the plugin put an unreasonable overhead on lcdproc loading times?
\end{itemize}

\chapter*{Methodology}

\chapter*{Implementation}

The plugin is implemented in C, using the C99 standard, to support as many platforms as possible.

\section{Plugin}
The toml parser is realized as an elektra storage plugin. The plugin exposes two functions, \textbf{elektraTomlGet} for reading, and \textbf{elektraTomlSet} for writing.

\section{Tools}
It uses two external tools for generating a parser for the toml file format: \acrshort{FLEX} \cite{flexgit} for lexical analysis and bison \cite{bisonmain} for parsing.
The key generation is done in the bison parser with the use of actions.

In order to generate the appropriate Elektra keys, the parser has access to a driver which contains all needed Elektra logic.
We oriented on the existing Elektra plugin \textbf{yambi}\cite{elektrayambi} in the key generation with the driver.
The driver contains functions of the style \textbf{driverEnterKey}/\textbf{driverExitTable} to make it more clear, at what point of parsing a certain function shall be invoked.

\section{Grammar}
TODO: Better structure
Since bison generates \acrshort{LR} (\acrlong{LR}) parsers, rules need to be left-recursive.
TODO: Add source, explain it.

The parser also makes use of so-called midrule-actions, which are parser actions that are not at the end of a grammar rule.
This can affect the resulting grammar, since after executing a mid-rule action, the parser has to commit to the chosen parse branch \cite{bisonmidruleconflicts}.

As a result, two important points had to be considered when creating the toml grammar:
\begin{itemize}
	\item Create only left-recursive rules.
	\item Avoid midrule-actions when possible.
\end{itemize}

The created parser only contains left-recursive rules.
We tried to minimize the usage of midrule-actions, to make the grammar as independent of the actions as possible.
However, especially for possibly nested structures, like arrays or inline tables, they were unavoidable.

\chapter*{Evaluation}

\chapter*{Related Work}

\chapter*{Conclusion}

\chapter*{Glossary}

\printglossary[type=\acronymtype]

\bibliography{references}{}
\bibliographystyle{plain}

\end{document}
