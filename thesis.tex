
%Remove these comments at end if they are fulfilled

% Before you begin, make sure that:
% - research question is clear
% - main points(contribution)+goal are clear (to be repeated throughout+title)
% - clear validation, evaluation, method of exactly the research question with main points as outcome!!!
% - Brainstorming was done
% - Roter Faden was done (Strukturierung und Elimination of Abzweigung)



\iffalse
NOTES:
- Why TOML?
	* Used by many projects
		-> eg cargo, pip -> where exactly
		-> possiblities for usage of elektra
	* No TOML plugin existing (only via augeas plugin)
- What was done?
	* TOML storage plugin for elektra
	* For now limited to reading toml files
	* uses c, flex, bison
- Case Study
	* lcdproc

	
\fi

\documentclass[12pt]{report}
\usepackage[utf8]{inpute nc}
\usepackage[acronym,nomain]{glossaries}
\usepackage{cite}
\usepackage{hyperref}
\usepackage{tcolorbox}

\title{Viability of TOML parsing for configuration}
\author{Jakob Fischer}


\bibliographystyle{unsrt}
\makeglossaries

\newacronym{ll}{LL}{Left-to-Right, Leftmost derivation}
\newacronym{lr}{LR}{Left-to-Right, Rightmost derivation}
\newacronym{toml}{TOML}{Tom's Obvious, Minimal Language}
\newacronym{flex}{FLEX}{Fast Lexical Analyzer}

\newcommand{\onlinesrc}[1]{Accessed #1}
\newcommand{\gitsrc}[1]{Commit \##1}

\begin{document}

\maketitle

\begin{abstract}
TODO: Abstract
\end{abstract}

\chapter{Introduction}


\section{\acrshort{toml} (\acrlong{toml})}
\acrshort{toml} is a configuration file format developed since February, 2013 \cite{tomlcontrib}.
It claims to be a format, that is easily to read and parse \cite{tomlreadme} and finds use in many different projects \cite{tomlwiki}.
For instance, it is used with Rusts project manager \textbf{cargo} \cite{cargogit}, as well as Pythons package installer \textbf{pip} \cite{piprefguide}.

\section{Elektra}
Elektra is a configuration framework for accessing configuration settings in a global key database \cite{elektramain}.
An application using Elektra can read and write key/value pairs via calls to the Elektra library, making the implementation of an own configuration system obsolete.
Furthermore, elektrified applications can access configuration settings of other elektrified applications, to provide better application interoperability.

Although Elektra is mainly written in C, there are bindings for other languages like java, python or ruby \cite{elektrabindings}.

Elektra can also read from and write to different configuration file formats, like JSON, XML or ini \cite{elektrastorage}.
If the need arises, applications can easily switch to a different file format, because configuration access is done with the Elektra API.
Developers or Administrators no longer need to commit to one file format for configuration.

Support for different languages and file formats is implemented by the use of plugins, which can be enabled if needed.
With this modularity, Elektra can provide a wide range of functionality, while simultaneously avoiding being a bloated library.
Developers can compile Elektra with the exact set of needed functionality. If they don't need bindings for java, they can just disable this feature.

\section{lcdproc}
LCDproc is an open source project for displaying stats like CPU/RAM usage of a system on different kinds of LCD devices \cite{lcdprocmain}\cite{lcdprocgit}.
It has a client/server architecture, where the clients provide their system stats to the server, which can display them on a LCD device.

\section{Research Question}
We will test the newly written toml plugin on ElektraInitiative's fork of lcdproc, where lcdproc is currently in the process of using elektra for it's handling of configuration.
The toml plugin will be used as the storage plugin for the lcdproc configuration.
We will create a \acrshort{toml} configuration file based lcdproc's main configuration file for evaluation.

There are two important questions we want to answer for the toml plugin:
\begin{itemize}
	\item[\textbf{RQ1}] Does the plugin correctly store and load all needed lcdproc configuration?
	\item[\textbf{RQ2}] Does the plugin put an unreasonable overhead on lcdproc loading times?
\end{itemize}
Since the lcdproc fork has an elektra specification which loads missing keys with defaults, we must ensure during the evaluation, that we are really using the values supplied by our configuration file, and not the default ones.

\chapter{Implementation}

The plugin is implemented in C, using the C99 standard. It requires POSIX for it's capabilities to check regular expressions.

\section{Plugin}
The toml parser is realized as an elektra storage plugin. The plugin exposes two functions, \textbf{elektraTomlGet} for reading, and \textbf{elektraTomlSet} for writing, as expected of a storage plugin.

\section{Tools}
It uses two external tools for generating a parser for the toml file format: \textbf{\acrshort{flex}} \cite{flexgit} for lexical analysis and \textbf{bison} \cite{bisonmain} for parsing.
The key generation is done in the bison parser with the use of actions.

In order to generate the appropriate Elektra keys, the parser has access to a driver which contains all needed Elektra logic.
We oriented on the existing Elektra plugin \textbf{yambi}\cite{elektrayambi} in key generation via driver.
The driver contains functions of the style \textbf{driverEnterKey}/\textbf{driverExitTable}, to make it more clear at what point of parsing a certain function shall be invoked.

\section{Grammar}
Since bison generates \acrshort{lr} (\acrlong{lr}) parsers, grammar rules should be be left-recursive.
Otherwise, we could run out of stack memory, if recursing too deep with a right-recursive rule.
The created parser only contains left-recursive rules.
TODO: Maybe explain better/examples/sources

The parser makes use of so-called midrule-actions, which are parser actions that are not at the end of a grammar rule.
This can affect the resulting grammar, since after executing a mid-rule action, the parser has to commit to the chosen parse branch \cite{bisonmidruleconflicts}.
We tried to minimize the usage of midrule-actions, to make the grammar as independent of actions as possible.
However, especially for possibly nested structures, like arrays or inline tables, they were unavoidable.



\chapter{Evaluation}

\section{Setup}
\begin{sloppypar}
For Elektra, we will use the elektra fork from \cite{bauhausforkelektra}, branch \textbf{'plugin\_toml'}, commit \#efdec83f9645d94081c3d0abcd43554fa5f63f88.
For LCDproc, we use the fork from \cite{bauhausforklcdproc}, branch \textbf{'toml\_test'}, commit \#70bf70135190c270c6a75e0b975f591df323bb65.
\end{sloppypar}
We clone both of this repositories in a single directory, our 'working directory'.

After cloning and checking out the two repositories, we build a docker image with the help of a script that comes with the repository:
\begin{tcolorbox}
\begin{verbatim}
cd libelektra
docker build -t buildelektra-buster \
    --build-arg JENKINS_USERID=`id -u` \
    --build-arg JENKINS_GROUPID=`id -g` \
    -f scripts/docker/debian/buster/Dockerfile \
    scripts/docker/debian/buster/
\end{verbatim}
\end{tcolorbox}

We extend this image by building another image on top of it. This dockerfile installs flex, which is needed by the toml plugin, sudo for installing elektra and lcdproc, and some other packages for convenience.

Dockerfile:
\begin{tcolorbox}
\small
\begin{verbatim}
FROM buildelektra-buster

USER root
RUN apt-get update && apt-get -y install flex vim sudo tmux
RUN adduser jenkins sudo
RUN echo '%sudo ALL=(ALL) NOPASSWD:ALL' >> /etc/sudoers
USER jenkins
WORKDIR /home/jenkins
\end{verbatim}
\end{tcolorbox}

We execute the following command from the same directory as the Dockerfile to create the image:
\begin{tcolorbox}
\small
\begin{verbatim}
docker build -t buildelektra-test-toml - < Dockerfile
\end{verbatim}
\end{tcolorbox}

Afterwards, we run the newly created image with the following command from our working directory:
\begin{tcolorbox}
\small
\begin{verbatim}
docker run -it --rm \
    -v $PWD:/home/jenkins \
    buildelektra-test-toml \
    bash
\end{verbatim}
\end{tcolorbox}

Within that container, we will now install Elektra and LCDproc:
\begin{tcolorbox}
\small
\begin{verbatim}
# Install Elektra
mkdir -p build
cd build
cmake \
    -DPLUGINS='MAINTAINED;toml' \
    ../libelektra
make
sudo make install
# Install LCDproc
cd ../lcdproc
sh ./autogen.sh
./configure
make
sudo make install
sudo ldconfig
./post-install.sh
kdb set '/sw/lcdproc/lcdd/#0/current/server/drivers/#0' \
    '@/curses/#0'
\end{verbatim}
\end{tcolorbox}
With Elektra and LCDproc successfuly installed, we now have all set up for evaluation.
All evaluation is done within the container environment which we just set up and where we installed elektra and lcdproc.

\section{Evaluation}
When we go back into our working directory and change into the '.config' directory, we now see a LCDd.toml file, containing only two lines of code:
\begin{tcolorbox}
\begin{verbatim}
server.driverpath = "/usr/local/lib/lcdproc/"
server.drivers = ["@/curses/#0"]
\end{verbatim}

\end{tcolorbox}
The first line sets our driver path and is generated automatically.

The second line declares our used drivers. This key was set by us in the last part of the installation, when we executed \texttt{kdb set}.
This line shows that the \acrshort{toml} plugin correctly detected, that the key we created is an array.
We indicated this, by ending the name of the key with '\#0', which is the index of our entry.
\\
With this minimal manual configuration, it is already possible to execute the LCDd-daemon and a lcdproc client.
At this point, the \acrshort{toml} plugin does only parse the two lines of configuration, the missing values are loaded from the defaults defined in the LCDd specification.
\\\\
Since the default configuration file is very minimal, we created a LCDd \acrshort{toml} file based on the old default configuration file of LCDd \cite{lcdprocconf}.
We converted this old configuration from it's ini like format into \acrshort{toml}.
We also removed all driver configuration settings, which are not referenced in the specification.
To show the full capability of the parser, the syntax of some lines was changed into a semantically equivalent format.
The resulting \acrshort{toml} file has over 600 lines, many of them comments.

During the conversion, it was very helpful, that the \acrshort{toml} plugin prints the linenumber of invalid \acrshort{toml} lines.

As an example, when we missed to put a value string into quotation marks and tried to start LCDd, we got the following error message:
\begin{tcolorbox}
\small
\begin{verbatim}
An error occurred while initializing elektra:
Validation Semantic: Line ~1045:
Malformed input: Found bare string on rhs, but is not allowed
\end{verbatim}
\end{tcolorbox}

To use this configuration file, we copy the \texttt{LCDd.toml} file from the lcdproc directory into the \texttt{.config} directory.
The LCDd daemon also starts without errors with this new configuration.
We can verify, that lcdproc used the curses driver options by checking the color the stats panel, which changed from red (which is the default value) to yellow, as written in our file.
\chapter{Related Work}

\chapter{Conclusion}

\chapter{Glossary}

\printglossary[type=\acronymtype]

\bibliography{references}{}
\bibliographystyle{plain}

\end{document}
